#ifndef __omc_Control_h_
#define __omc_Control_h_
#include "adevs.h"
#include "adevs_public_modelica_runtime.h"

/**
 * Define the input and output type of the adevs models.
 */
#ifndef OMC_ADEVS_IO_TYPE
#define OMC_ADEVS_IO_TYPE double
#endif

/**
 * Simulation code for Control
 * generated by the OpenModelica Compiler.
 */
class Control:
    public adevs::ode_system<OMC_ADEVS_IO_TYPE>
{
    public:
       /**
        * Constructor. New state events can be added to the model by
        * passing the number of new event conditions to the constructor
        * and then extending the state_event_func method. Your state
        * events will begin at the index returned by numStateEvents().
        * You can also set the hysteresis value for the event surfaces
        * by passing a value for eventHys.
        */
       Control(int extra_state_events = 0, double eventHys = 1E-4);
       /// Destructor
       ~Control();
       /// Index of the first extra state event
       int numStateEvents() const { return numZeroCrossings(); }
       /**
        * These methods are generated by the OpenModelica compiler.
        */
       void init(double* q);
       void der_func(const double* q, double* dq);
       void postStep(double* q);
       void state_event_func(const double* q, double* z);
       /**
        * These methods may be overridden by any derived class.
        */
       virtual void extra_state_event_funcs(double* z){}
       double time_event_func(const double* q);
       void internal_event(double* q, const bool* state_event);
       void external_event(double* q, double e,
           const adevs::Bag<OMC_ADEVS_IO_TYPE>& xb){}
       void confluent_event(double *q, const bool* state_event,
           const adevs::Bag<OMC_ADEVS_IO_TYPE>& xb)
       {
           internal_event(q,state_event);
       }
       void output_func(const double *q, const bool* state_event,
           adevs::Bag<OMC_ADEVS_IO_TYPE>& yb){}
       void gc_output(adevs::Bag<OMC_ADEVS_IO_TYPE>& gb){}
       /**
        * These methods are used to access variables and
        * parameters in the modelica model by name.
        */
       double getEventEpsilon() const { return epsilon; }
       double get_time() const { return timeValue; }
       double get_$dummy() const { return _$dummy; }
       double get_DER_$dummy() const { return _DER_$dummy; }
       double get_qd2() const { return _qd2; }
       double get_qd1() const { return _qd1; }
       double get_zd() const { return _zd; }
       double get_xd() const { return _xd; }
       double get_pi() const { return _pi; }
       double get_xp() const { return _xp; }
       double get_L() const { return _L; }
       double get_l() const { return _l; }
       
       /// These methods are for solving non-linear algebraic eqns
       void residualFunc11_cpp(double* y, double* res);
       void solve_residualFunc11_cpp();
       void residualFunc13_cpp(double* y, double* res);
       void solve_residualFunc13_cpp();
       // Calculate the minimization function for initializing reals
       void initial_objective_func(double* w, double* f, double lambda);
       
    private:
       // State variables
       double _$dummy; double _PRE_$dummy;
       // Derivative variables
       double _DER_$dummy; double _PRE_DER_$dummy;
       // Algebraic variables
       double _qd2; double _PRE_qd2;
       double _qd1; double _PRE_qd1;
       double _zd; double _PRE_zd;
       double _xd; double _PRE_xd;
       // Integer algebraic variables
       // Boolean algebraic variables
       // Alias variables
       // Integer alias variables
       // Boolean alias variables
       // Parameter variables
       double _pi; double _PRE_pi;
       double _xp; double _PRE_xp;
       double _L; double _PRE_L;
       double _l; double _PRE_l;
       // Integer parameter variables
       // Boolean parameter variables
       // String variables
       // String parameters
       // External object variables
       // Constants
       // Integer constants
       // Boolean constants
       // String constants

       
       double epsilon;
       // These must be accessed via a pointer to localVal
       double timeValue, _PRE_timeValue;
       // Are we at an event?
       bool atEvent;
       // Are we initializing the model?
       bool atInit;
       
       // Zero crossing variables
       int *zc;
       int numZeroCrossings() const {
            return numRelations()+2*numMathEvents();
       }
       int numRelations() const { return 0; }
       int numMathEvents() const { return 0; }
       
       // Initial unknowns via solution to least squares
       void solve_for_initial_unknowns();
       std::vector<double*> init_unknown_vars;
       void bound_params();
       void save_vars();
       void restore_vars();
       void clear_event_flags();
       bool check_for_new_events();
       bool initial() const { return atInit; }
       
       void calc_vars(const double* q = NULL, bool doReinit = false);
       
       AdevsSampleData** samples;
       int numTimeEvents() const { return 0; }
       bool sample(int index, double tStart, double tInterval);
       
       AdevsDelayData** delays;
       int numDelays() const { return 0; }
       double calcDelay(int index, double expr, double t, double delay);
       void saveDelay(int index, double expr, double t, double maxdelay);
       
       AdevsMathEventFunc** eventFuncs;
       double floor(double expr, int index);
       double div(double x, double y, int index);
       int integer(double expr, int index);
       double ceil(double expr, int index);
       
       bool selectStateVars();
       
    protected:
       /**
        * Calculate the values of the state and algebraic variables.
        * State variables will be initialized to q if provided,
        * or left unchanged if not. This should be called after your
        * event handler modifies any state variables that
        * appear in the Modelica equations.
        */
       void update_vars(const double* q = NULL, bool doReinit = false)
       {
           calc_vars(q,doReinit);
           for (int i = 0; i < numMathEvents(); i++)
              if (eventFuncs[i] != NULL)
                 eventFuncs[i]->setInit(false);
           save_vars();
       }
       /**
         * These methods may be used to change paramters
         * and state variables at events. Remember to call
         * update_vars(q,true) if you change anything.
         */
       void set_$dummy(double val) { _$dummy = val; }
       void set_pi(double val) { _pi = val; }
       void set_xp(double val) { _xp = val; }
       void set_L(double val) { _L = val; }
       void set_l(double val) { _l = val; }
 };

 #endif

