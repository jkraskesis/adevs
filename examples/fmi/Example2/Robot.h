#ifndef __omc_Robot_h_
#define __omc_Robot_h_
#include "adevs.h"
#include "adevs_public_modelica_runtime.h"

/**
 * Define the input and output type of the adevs models.
 */
#ifndef OMC_ADEVS_IO_TYPE
#define OMC_ADEVS_IO_TYPE double
#endif

/**
 * Simulation code for Robot
 * generated by the OpenModelica Compiler.
 */
class Robot:
    public adevs::ode_system<OMC_ADEVS_IO_TYPE>
{
    public:
       /**
        * Constructor. New state events can be added to the model by
        * passing the number of new event conditions to the constructor
        * and then extending the state_event_func method. Your state
        * events will begin at the index returned by numStateEvents().
        * You can also set the hysteresis value for the event surfaces
        * by passing a value for eventHys.
        */
       Robot(int extra_state_events = 0, double eventHys = 1E-4);
       /// Destructor
       ~Robot();
       /// Index of the first extra state event
       int numStateEvents() const { return numZeroCrossings(); }
       /**
        * These methods are generated by the OpenModelica compiler.
        */
       void init(double* q);
       void der_func(const double* q, double* dq);
       void postStep(double* q);
       void state_event_func(const double* q, double* z);
       /**
        * These methods may be overridden by any derived class.
        */
       virtual void extra_state_event_funcs(double* z){}
       double time_event_func(const double* q);
       void internal_event(double* q, const bool* state_event);
       void external_event(double* q, double e,
           const adevs::Bag<OMC_ADEVS_IO_TYPE>& xb){}
       void confluent_event(double *q, const bool* state_event,
           const adevs::Bag<OMC_ADEVS_IO_TYPE>& xb)
       {
           internal_event(q,state_event);
       }
       void output_func(const double *q, const bool* state_event,
           adevs::Bag<OMC_ADEVS_IO_TYPE>& yb){}
       void gc_output(adevs::Bag<OMC_ADEVS_IO_TYPE>& gb){}
       /**
        * These methods are used to access variables and
        * parameters in the modelica model by name.
        */
       double getEventEpsilon() const { return epsilon; }
       double get_time() const { return timeValue; }
       double get_$STATESET1_x(int i0) const { return _$STATESET1_x.get(i0); }
       double get_$STATESET2_x(int i0) const { return _$STATESET2_x.get(i0); }
       double get_DER_$STATESET1_x(int i0) const { return _DER_$STATESET1_x.get(i0); }
       double get_DER_$STATESET2_x(int i0) const { return _DER_$STATESET2_x.get(i0); }
       double get_M(int i0) const { return _M.get(i0); }
       double get_JxT(int i0,int i1) const { return _JxT.get(i0,i1); }
       double get_Ttplate(int i0) const { return _Ttplate.get(i0); }
       double get_Tfarm(int i0) const { return _Tfarm.get(i0); }
       double get_Tarm(int i0) const { return _Tarm.get(i0); }
       double get_Tfric(int i0) const { return _Tfric.get(i0); }
       double get_Tred(int i0) const { return _Tred.get(i0); }
       double get_JqInv(int i0,int i1) const { return _JqInv.get(i0,i1); }
       double get_error() const { return _error; }
       double get_q2_sample() const { return _q2_sample; }
       double get_q1_sample() const { return _q1_sample; }
       double get_dq2() const { return _dq2; }
       double get_dq1() const { return _dq1; }
       double get_dz() const { return _dz; }
       double get_dx() const { return _dx; }
       double get_q2() const { return _q2; }
       double get_q1() const { return _q1; }
       double get_z() const { return _z; }
       double get_x() const { return _x; }
       double get_zd() const { return _zd; }
       double get_xd() const { return _xd; }
       double get_DER_dq1() const { return _DER_dq1; }
       double get_DER_dx() const { return _DER_dx; }
       double get_DER_dq2() const { return _DER_dq2; }
       double get_DER_dz() const { return _DER_dz; }
       double get_$TMP_33(int i0) const { return _$TMP_33.get(i0); }
       int get_$STATESET2_A(int i0,int i1) const { return _$STATESET2_A.get(i0,i1); }
       int get_$STATESET1_A(int i0,int i1) const { return _$STATESET1_A.get(i0,i1); }
       int get_sampleNumber() const { return _sampleNumber; }
       double get_T(int i0) const { return _T.get(i0); }
       double get_pi() const { return _pi; }
       double get_xp() const { return _xp; }
       double get_L() const { return _L; }
       double get_l() const { return _l; }
       double get_m1() const { return _m1; }
       double get_m2() const { return _m2; }
       double get_m3() const { return _m3; }
       double get_ml() const { return _ml; }
       double get_Jmot() const { return _Jmot; }
       double get_Jred() const { return _Jred; }
       double get_I() const { return _I; }
       double get_Fs() const { return _Fs; }
       double get_Fv() const { return _Fv; }
       double get_nu() const { return _nu; }
       double get_g() const { return _g; }
       double get_sampleFreq() const { return _sampleFreq; }
       double get_DER_q1() const { return _DER_q1; }
       double get_DER_q2() const { return _DER_q2; }
       double get_DER_x() const { return _DER_x; }
       double get_DER_z() const { return _DER_z; }
       
       /// These methods are for solving non-linear algebraic eqns
       void residualFunc38_cpp(double* y, double* res);
       void solve_residualFunc38_cpp();
       // Calculate the minimization function for initializing reals
       void initial_objective_func(double* w, double* f, double lambda);
       
    private:
       // State variables
       modelica_array<double> _$STATESET1_x; modelica_array<double> _PRE_$STATESET1_x;
        
       modelica_array<double> _$STATESET2_x; modelica_array<double> _PRE_$STATESET2_x;
        
       // Derivative variables
       modelica_array<double> _DER_$STATESET1_x; modelica_array<double> _PRE_DER_$STATESET1_x;
        
       modelica_array<double> _DER_$STATESET2_x; modelica_array<double> _PRE_DER_$STATESET2_x;
        
       // Algebraic variables
       modelica_array<double> _M; modelica_array<double> _PRE_M;
        
       modelica_array<double> _JxT; modelica_array<double> _PRE_JxT;
        
        
        
       modelica_array<double> _Ttplate; modelica_array<double> _PRE_Ttplate;
        
       modelica_array<double> _Tfarm; modelica_array<double> _PRE_Tfarm;
        
       modelica_array<double> _Tarm; modelica_array<double> _PRE_Tarm;
        
       modelica_array<double> _Tfric; modelica_array<double> _PRE_Tfric;
        
       modelica_array<double> _Tred; modelica_array<double> _PRE_Tred;
        
       modelica_array<double> _JqInv; modelica_array<double> _PRE_JqInv;
        
        
        
       double _error; double _PRE_error;
       double _q2_sample; double _PRE_q2_sample;
       double _q1_sample; double _PRE_q1_sample;
       double _dq2; double _PRE_dq2;
       double _dq1; double _PRE_dq1;
       double _dz; double _PRE_dz;
       double _dx; double _PRE_dx;
       double _q2; double _PRE_q2;
       double _q1; double _PRE_q1;
       double _z; double _PRE_z;
       double _x; double _PRE_x;
       double _zd; double _PRE_zd;
       double _xd; double _PRE_xd;
       double _DER_dq1; double _PRE_DER_dq1;
       double _DER_dx; double _PRE_DER_dx;
       double _DER_dq2; double _PRE_DER_dq2;
       double _DER_dz; double _PRE_DER_dz;
       modelica_array<double> _$TMP_33; modelica_array<double> _PRE_$TMP_33;
        
       // Integer algebraic variables
       modelica_array<int> _$STATESET2_A; modelica_array<int> _PRE_$STATESET2_A;
        
        
        
        
        
        
        
       modelica_array<int> _$STATESET1_A; modelica_array<int> _PRE_$STATESET1_A;
        
        
        
        
        
        
        
       int _sampleNumber; int _PRE_sampleNumber;
       // Boolean algebraic variables
       // Alias variables
       double _DER_q1; double _PRE_DER_q1;
       double _DER_q2; double _PRE_DER_q2;
       double _DER_x; double _PRE_DER_x;
       double _DER_z; double _PRE_DER_z;
       // Integer alias variables
       // Boolean alias variables
       // Parameter variables
       modelica_array<double> _T; modelica_array<double> _PRE_T;
        
       double _pi; double _PRE_pi;
       double _xp; double _PRE_xp;
       double _L; double _PRE_L;
       double _l; double _PRE_l;
       double _m1; double _PRE_m1;
       double _m2; double _PRE_m2;
       double _m3; double _PRE_m3;
       double _ml; double _PRE_ml;
       double _Jmot; double _PRE_Jmot;
       double _Jred; double _PRE_Jred;
       double _I; double _PRE_I;
       double _Fs; double _PRE_Fs;
       double _Fv; double _PRE_Fv;
       double _nu; double _PRE_nu;
       double _g; double _PRE_g;
       double _sampleFreq; double _PRE_sampleFreq;
       // Integer parameter variables
       // Boolean parameter variables
       // String variables
       // String parameters
       // External object variables
       // Constants
       // Integer constants
       // Boolean constants
       // String constants

       // Diff vars: _dz,_dq2,_dx,_dq1
       // Diffed vars: _$STATESET1_J.get(0),_$STATESET1_J.get(1)
       double _Jacobian_StateSetJac1[2*4];
       void calc_Jacobian_StateSetJac1();
       long int colSelect_$STATESET1_A[4];
       long int rowSelect_$STATESET1_A[2];
       // Diff vars: _z,_q1,_x,_q2
       // Diffed vars: _$STATESET2_J.get(0),_$STATESET2_J.get(1)
       double _Jacobian_StateSetJac0[2*4];
       void calc_Jacobian_StateSetJac0();
       long int colSelect_$STATESET2_A[4];
       long int rowSelect_$STATESET2_A[2];
       
       double epsilon;
       // These must be accessed via a pointer to localVal
       double timeValue, _PRE_timeValue;
       // Are we at an event?
       bool atEvent;
       // Are we initializing the model?
       bool atInit;
       
       // Zero crossing variables
       int *zc;
       int numZeroCrossings() const {
            return numRelations()+2*numMathEvents();
       }
       int numRelations() const { return 0; }
       int numMathEvents() const { return 0; }
       
       // Initial unknowns via solution to least squares
       void solve_for_initial_unknowns();
       std::vector<double*> init_unknown_vars;
       void bound_params();
       void save_vars();
       void restore_vars();
       void clear_event_flags();
       bool check_for_new_events();
       bool initial() const { return atInit; }
       
       void calc_vars(const double* q = NULL, bool doReinit = false);
       
       AdevsSampleData** samples;
       int numTimeEvents() const { return 1; }
       bool sample(int index, double tStart, double tInterval);
       
       AdevsDelayData** delays;
       int numDelays() const { return 0; }
       double calcDelay(int index, double expr, double t, double delay);
       void saveDelay(int index, double expr, double t, double maxdelay);
       
       AdevsMathEventFunc** eventFuncs;
       double floor(double expr, int index);
       double div(double x, double y, int index);
       int integer(double expr, int index);
       double ceil(double expr, int index);
       
       bool selectStateVars();
       
    protected:
       /**
        * Calculate the values of the state and algebraic variables.
        * State variables will be initialized to q if provided,
        * or left unchanged if not. This should be called after your
        * event handler modifies any state variables that
        * appear in the Modelica equations.
        */
       void update_vars(const double* q = NULL, bool doReinit = false)
       {
           calc_vars(q,doReinit);
           for (int i = 0; i < numMathEvents(); i++)
              if (eventFuncs[i] != NULL)
                 eventFuncs[i]->setInit(false);
           save_vars();
       }
       /**
         * These methods may be used to change paramters
         * and state variables at events. Remember to call
         * update_vars(q,true) if you change anything.
         */
       void set_$STATESET1_x(double val, int i0) const { _$STATESET1_x.get(i0) = val; }
       void set_$STATESET2_x(double val, int i0) const { _$STATESET2_x.get(i0) = val; }
       void set_T(double val, int i0) const { _T.get(i0) = val; }
       void set_pi(double val) { _pi = val; }
       void set_xp(double val) { _xp = val; }
       void set_L(double val) { _L = val; }
       void set_l(double val) { _l = val; }
       void set_m1(double val) { _m1 = val; }
       void set_m2(double val) { _m2 = val; }
       void set_m3(double val) { _m3 = val; }
       void set_ml(double val) { _ml = val; }
       void set_Jmot(double val) { _Jmot = val; }
       void set_Jred(double val) { _Jred = val; }
       void set_I(double val) { _I = val; }
       void set_Fs(double val) { _Fs = val; }
       void set_Fv(double val) { _Fv = val; }
       void set_nu(double val) { _nu = val; }
       void set_g(double val) { _g = val; }
       void set_sampleFreq(double val) { _sampleFreq = val; }
 };

 #endif

