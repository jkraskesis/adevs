#include "adevs/adevs.h"
#include <iostream>

/**
 * This example shows how to two connect to Atomic models
 * to form a larger model. The first component produces
 * output and changes its state with a fixed period. The
 * second component receives its input from the first 
 * component. Here are console messages printed by this
 * simulation:
 *
 * Next event is @ time 1
 * Supplier Output: 0
 * Supplier State: 1
 * Consumer received input: 0
 * Next event is @ time 2
 * Supplier Output: 1
 * Supplier State: 2
 * Consumer received input: 1
 * 
 * The Simulator calculates the time of next event as the
 * smaller of the first component's time advance and the
 * second component's time advance. Because the time advance
 * of the second component will always be infinity, only
 * the first component places a meaningful role in causing
 * the simulation clock to advance.
 *
 * At the next event time, the Simulator calls the output
 * function of the first component. This component places
 * the output it wishes to produce into the list supplied
 * to its output function. Then the contents of the list 
 * are routed, via the Graph supplied to the Simulator,
 * to the second component.
 * 
 * Finally, the Simulator calls the internal transition function
 * of the first component and the external transition function
 * of the second components. 
 */

 /**
  * Our Supplier is derived from the Atomic class and it
  * is essentially identical to the Periodic model of
  * Example #1. The only differences are that (1) it
  * has a pin_t member variable that will be used to connect
  * the models and (2) it places a PinValue object into the
  * output list.
  */
class Supplier : public adevs::Atomic<> {
public:
    /// Our constructor calls the default constructor and sets the
    /// initial value of a counter member variable, which is the
    /// state of our model.
    Supplier() : adevs::Atomic<>(), state(0) {}
    /// The time advance function is used by the Simulator class
    /// to schedule our next event. We return 1.0 to tell the simulator
    /// that our events occur at times 1, 2, 3, and so forth.
    double ta() { return 1.0; }
    /// We produce our current state as the output value before changing
    /// the state in the internal transition function.
    void output_func(std::list<adevs::PinValue<>>& yb) {
        yb.push_back(adevs::PinValue<>(pin, state));
        std::cout << "Supplier Output: " << state << std::endl;
    }
    /// We change our state by incrementing it in our internal transition function.
    void delta_int() {
        state++;
        std::cout << "Supplier State: " << state << std::endl;
    }
    /// The external transition function is not used in this example.
    /// It is never called by the Simulator.
    void delta_ext(double, std::list<adevs::PinValue<>> const&) {}
    /// The confluent transition function is not used in this example,
    /// It is never called by the Simulator.
    void delta_conf(std::list<adevs::PinValue<>> const&) {}

    /// The single pin that will connect the models
    const adevs::pin_t pin;

private:
    /// The state of our model is a single integer
    int state;
};

/**
 * The Consumer is derived from the Atomic class and its
 * only function is to receive the output generated by
 * the Supplier. This model does not schedule changes of
 * state or output for itself, and it indicates this to
 * the Simulator by returning infinity from its time advance
 * function.
 * 
 * In this example, we simply echo the input that is received
 * from the Supplier. The internal transition function, 
 * confluent transition function, and output function are
 * never called by the Simulator.
 */
class Consumer : public adevs::Atomic<> {
public:
    /// Our constructor calls the default constructor.
    Consumer() : adevs::Atomic<>() {}
    /// The time advance function returns infinity to indicate
    /// that we have no events of our own.
    double ta() { return adevs_inf<double>(); }
    /// The output function is never called by the Simulator.
    void output_func(std::list<adevs::PinValue<>>&) {}
    /// The internal transition function is never called by the Simulator.
    void delta_int() {}
    /// The external transition function receives input from the Supplier
    /// via the connections established by the Graph that is create in
    /// main() and passed to the Simulator.
    void delta_ext(double, std::list<adevs::PinValue<>> const &xb) {
        for (const auto &input : xb) {
            std::cout << "Consumer received input: " << std::any_cast<int>(input.value) << std::endl;
        }
    }
    /// The confluent transition function is never called by the Simulator.
    void delta_conf(std::list<adevs::PinValue<>> const&) {}
};

/**
 * The main function creates a Simulator for our Periodic model and runs
 * the simulation for 2 units of time.
 */
int main() {
    /// Create an instance of the Supplier model in a shared pointer
    auto A = std::make_shared<Supplier>();
    /// Create an instance of the Consumer model in a shared pointer
    auto B = std::make_shared<Consumer>();
    /// Create a Graph to connect the two models
    auto graph = std::make_shared<adevs::Graph<>>();
    /// Add the Atomic components to the Graph
    graph->add_atomic(A);
    graph->add_atomic(B);
    /// PinValue objects that appears as output with A->pin as
    /// their pin member will be supplied as input to B
    graph->connect(A->pin, B);
    /// Create a Simulator for the Graph
    adevs::Simulator<> simulator(graph);
    /// Run the simulator for 2 units of time
    while (simulator.nextEventTime() <= 2.0) {
        /// Report when the next event will occur
        std::cout << "Next event is @ time " << simulator.nextEventTime() << std::endl;
        /// Execute the next event at that time
        simulator.execNextEvent();
    }
    /// Done!
    return 0;
}
